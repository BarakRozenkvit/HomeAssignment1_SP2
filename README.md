# מטלה 1 - גרפים
___
`Graph.hpp` מימוש מחלקת הגרף
---

`loadGraph(vector<vector<int>> matrix)` טעינת מטריצת השכנויות לאובייקט הגרף 

`printGraph()` נדפיס את מספר הקודקודים והצלעות בגרף

`isDirected()` נחזיר האם הגרף מכוון או לא מכוון

`getEdges()` נחזיר את מספר הצלעות בגרף



`Algorithms.hpp` מימוש מחלקת האלגוריתמים
---
מחלקת האלגוריתמים היא מחלקה סטטית המורכבת משילוב של אלגוריתמים ידועים על גרפים מכוונים ולא מכוונים

אלגוריתמים ידועים:
- `BellmanFord(Graph g,int src)` מציאת מסלול קצר מקודקוד לשאר הקודקודים 
- `DFS(Graph g, stack<int> orderOfVertices)` סריקת קודקודים לעומק
- `twoColoringGraph(Graph g)` צביעת הגרף לשני צבעים
- `Transpose(Graph g)` היפוך צלעות בגרף

מימוש הפונקציות:

`bool isConnected(Graph g)`

פונקציה זו מומשה על פי אלגוריתם למציאת רכיבי קשירות חזקה בגרף. 
בעזרת אלגוריתם לסריקת קודקודים לעומק לפי סדר קודקודים מסוים.
כתוצאה מכך נקבל סדר יורד של קודקודים לפי זמני הסיום שלהם, 
נעשה היפוך צלעות
ונריץ שוב סריקת קודקודים לעומק לפי סדר הקודקוד שקיבלנו.
נבדוק אם מהתוצאה של הסריקה קיבלנו יער בעל עץ אחד, אם כן הגרף קשיר חזק.

`string shortestPath(Graph g,int src,int dest)`

פונקציה זו מומשה בעזרת אלגוריתם למציאת מסלול קצר מקודקוד לשאר הקודקוד,
אם מצאנו מסלול קצר נחזיר את מסלול ואם לא, נחזיר -1 

`string isContainsCycle(Graph g)`

פונקציה זו מומשה בעזרת אלגוריתם לסריקת קודקודים לעומק. באלגוריתם זה אם קיבלנו ״צלע אחורה״ (כאשר במהלך הסריקה נתקל בקודקוד אפור) האלגוריתם ישמור את שני הקוקודים.
אם קיבלנו צלע אחורה נחזיר את המעגל ואם לא, נחזיר 0

`string isBipartite(Graph g)`

פונקציה זו מומשה בעזרת אלגוריתם לצביעת הגרף ל2 צבעים, כלומר אם הגרף 2-צביע אפשר לחלק אותו לגרף דו צדדי.
נחזיר את החלוקה אם אפשר ואם לא, נחזיר 0

`string negativeCycle(Graph g)`

פונקציה זו מומשה בעזרת האלגוריתם למציאת המסלול הקצר שתיארתי לעיל, אלגוריתם זה יודע פועל למצוא גם אם קיים מעגל שלילי בגרף.
אם קיים מעגל שלילי נחזיר אותו ואם לא, נחזיר 0